{"mode":"Text","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\n\n# Brain should be defined by default\nbrain=Brain()\n\n# Robot configuration code\nbrain_inertial = Inertial()\nleft_drive_smart = Motor(Ports.PORT3, 3.0, False)\nright_drive_smart = Motor(Ports.PORT4, 3.0, True)\n\ndrivetrain = SmartDrive(left_drive_smart, right_drive_smart, brain_inertial, 200)\nIntake_motor_a = Motor(Ports.PORT1, True)\nIntake_motor_b = Motor(Ports.PORT6, False)\nIntake = MotorGroup(Intake_motor_a, Intake_motor_b)\nTray_motor_a = Motor(Ports.PORT2, True)\nTray_motor_b = Motor(Ports.PORT5, False)\nTray = MotorGroup(Tray_motor_a, Tray_motor_b)\ngyro_9 = Gyro(Ports.PORT9)\nbumper_8 = Bumper(Ports.PORT8)\ntouchled_10 = Touchled(Ports.PORT10)\n\n\n\n# Make random actually random\ndef setRandomSeedUsingAccel():\n    wait(100, MSEC)\n    xaxis = brain_inertial.acceleration(XAXIS) * 1000\n    yaxis = brain_inertial.acceleration(YAXIS) * 1000\n    zaxis = brain_inertial.acceleration(ZAXIS) * 1000\n    urandom.seed(int(xaxis + yaxis + zaxis))\n    \n# Set random seed \nsetRandomSeedUsingAccel()\n\nvexcode_initial_drivetrain_calibration_completed = False\ndef calibrate_drivetrain():\n    # Calibrate the Drivetrain Inertial\n    global vexcode_initial_drivetrain_calibration_completed\n    sleep(200, MSEC)\n    brain.screen.print(\"Calibrating\")\n    brain.screen.next_row()\n    brain.screen.print(\"Inertial\")\n    brain_inertial.calibrate()\n    while brain_inertial.is_calibrating():\n        sleep(25, MSEC)\n    vexcode_initial_drivetrain_calibration_completed = True\n    brain.screen.clear_screen()\n    brain.screen.set_cursor(1, 1)\n\n#endregion VEXcode Generated Robot Configuration\n# ------------------------------------------\n# \n# \tProject:      Full Volume VEXcode Project\n# \tAuthor:       Quartics Team\n# \tCreated:      01/02/2024\n# \tDescription:  Autonomous Full volume game play code\n# \n# ------------------------------------------\n\n# Library imports\nfrom vex import *\n\n# Begin project code\n\n# Method to rotate the robot in both clockwise (right turn) and anti-clockwise direction\n# (left turn). This method is used instead of VEX library method as the VEX methods \n# rotation is not close to the rotation angle provided. \n# This method is using gyro sensor for rotation\n# Input:  angle to rotate in Degrees. +ve value for left turn and -ve value for right turn\n# This code supports turns of less than 180 Degrees\ndef turn_robot(turn_angle_degrees):  \n    print(\"++++++\") \n    # reset gyro rotation\n    gyro_9.set_rotation(0, DEGREES)  \n    wait(20, MSEC)  \n\n    # based on gyro sensor reading calculate how much the robot needs to turn\n    error = turn_angle_degrees - gyro_9.rotation()        \n\n    # stop rotation when error is within 1 Degree of the input value\n    # this code was added as we saw that a high number of iterations were taken\n    # when error was less than 1 and robot would appear to be not doing anything \n    while math.fabs(error) > 1:  \n        #print(\"gyro rotation: \" + str(gyro_9.rotation()))  \n        #print(\"error: \", error)  \n\n        # for precise rotation reduce the velocity as the error starts to reduce\n        # if the error is a low value velocity becomes very small and so checking\n        # if the velocity is below a threshold value of 10. In that case set it to\n        # the threshold\n        velocity = math.fabs(error) * (50 / 180)  \n        if velocity < 10:  \n            velocity = 10  \n            #print(\"set velocity to: \", velocity)  \n    \n        # set velocity for both left and right motors to the calculated velocity\n        left_drive_smart.set_velocity(velocity, PERCENT)  \n        right_drive_smart.set_velocity(velocity, PERCENT) \n\n        # error is positive in case of left turn\n        # in this case right motor should spin forward and left motor should spin reverse\n        # error is negative in case of right turn\n        # in this case left motor should spin forward and right motor should spin reverse\n        if error > 0:  \n            #print(\"Positive\")  \n            left_drive_smart.spin(REVERSE)  \n            right_drive_smart.spin(FORWARD)   \n        else:  \n            #print(\"Negative\")  \n            left_drive_smart.spin(FORWARD)  \n            right_drive_smart.spin(REVERSE)  \n \n        # re-calculate error to determine remaining rotation angle\n        error = turn_angle_degrees - gyro_9.rotation()  \n\n    print(\"gyro rotation: \" + str(gyro_9.rotation()))  \n    print(\"error: \" + str(error))   \n    print(\"done\")\n    # reset drive train velocities in case they were reduced earlier\n    drivetrain.set_drive_velocity(25, PERCENT)\n    drivetrain.set_turn_velocity(25, PERCENT)\n\n    left_drive_smart.stop()\n    right_drive_smart.stop()  \n# Score function\n\ndef score():\n    if not bumper_8.pressing():\n        drivetrain.drive_for(REVERSE, 20, MM)\n        Tray.spin_for(FORWARD, 270, DEGREES)\n        wait(1, SECONDS)\n        Tray.spin_for(REVERSE, 270, DEGREES)\n    \n\n#part two is in a function because we want to use the LED sensor, \ndef partTwo():\n    wait(1, SECONDS)\n    drivetrain.drive_for(FORWARD, 762, MM)\n    wait(1, SECONDS)\n    turn_robot(-45)\n    wait(1, SECONDS)\n    drivetrain.drive_for(FORWARD, 266.7, MM)\n    wait(1, SECONDS)\n    drivetrain.drive_for(REVERSE, 304.8, MM)\n    wait(1, SECONDS)\n    turn_robot(45)\n    wait(1, SECONDS)\n    drivetrain.drive_for(REVERSE, 635, MM)\n    wait(1, SECONDS)\n    turn_robot(-135)\n    wait(1, SECONDS)\n    drivetrain.drive_for(FORWARD, 457.2, MM)\n    wait(1, SECONDS)\n    turn_robot(45)\n    wait(1, SECONDS)\n    drivetrain.drive_for(REVERSE, 546.1, MM)\n    wait(1, SECONDS)\n    score\n\n\n\n\n\n\n\n\n# Start Code\n# Setting gyro callibration and set our motor velocity as well as timeout\ngyro_9.calibrate(GyroCalibrationType.NORMAL)\ndrivetrain.set_drive_velocity(25, PERCENT)\ndrivetrain.set_turn_velocity(25, PERCENT)\ndrivetrain.set_timeout(3, SECONDS)\n\n\nIntake.spin(FORWARD)\nwhile Intake.velocity == 0:\n    Intake.set_velocity(-10,PERCENT)\nIntake.set_velocity(100,PERCENT)\n\nwhile True:\n    touchled_10.pressed(partTwo)\n    break\n\n    \n'''\n# Start path\ndrivetrain.drive_for(FORWARD, 890, MM)\nwait(1, SECONDS)\nturn_robot(105)\nwait(1, SECONDS)\ndrivetrain.drive_for(FORWARD, 900, MM)\nwait(1,SECONDS)\nturn_robot(90)\nwait(1,SECONDS)\ndrivetrain.set_drive_velocity(100, PERCENT)\nwait(1,SECONDS)\ndrivetrain.drive_for(REVERSE, 266.7, MM)\nwait(1, SECONDS)\nleft_drive_smart.spin_for(REVERSE, 15, DEGREES)\nwait(1,SECONDS)\ndrivetrain.drive_for(REVERSE, 241.3, MM)\nwait(1, SECONDS)\nright_drive_smart.spin_for(REVERSE, 15, DEGREES)\nscore()\ndrivetrain.stop()\nIntake.stop()\nTray.stop()\n'''\n\n\n#partTwo\n\n\n\n\n\n\n\n\n","textLanguage":"python","rconfig":[{"port":[3,4,0],"name":"drivetrain","customName":false,"deviceType":"Drivetrain","deviceClass":"smartdrive","setting":{"type":"2-motor","wheelSize":"200mm","gearRatio":"3:1","direction":"fwd","gyroType":"integrated","width":"173","unit":"mm","wheelbase":"76","wheelbaseUnit":"mm","xOffset":"0","yOffset":"0","thetaOffset":"0"},"triportSourcePort":22},{"port":[1,6],"name":"Intake","customName":true,"deviceType":"MotorGroup","deviceClass":"motor_group","setting":{"fwd":"forward","rev":"reverse","motor_a_reversed":"true","motor_b_reversed":"false"},"triportSourcePort":22},{"port":[2,5],"name":"Tray","customName":true,"deviceType":"MotorGroup","deviceClass":"motor_group","setting":{"fwd":"forward","rev":"reverse","motor_a_reversed":"true","motor_b_reversed":"false"},"triportSourcePort":22},{"port":[9],"name":"gyro_9","customName":false,"deviceType":"Gyro","deviceClass":"gyro","setting":{},"triportSourcePort":22},{"port":[8],"name":"bumper_8","customName":false,"deviceType":"Bumper","deviceClass":"bumper","setting":{},"triportSourcePort":22},{"port":[10],"name":"touchled_10","customName":false,"deviceType":"TouchLED","deviceClass":"touchled","setting":{}}],"slot":2,"platform":"IQ","sdkVersion":"20230818.11.00.00","appVersion":"3.0.4","minVersion":"3.0.0","fileFormat":"1.2.0","icon":"","targetBrainGen":"Second","v5SoundsEnabled":false,"target":"Physical"}